https://www.nowcoder.com/discuss/135748

Q1: 数据库基本特性:ACID
    web:
    ANS: 原子性(Atomicity整个事物中的所有操作,要么全部完成要么全部不完成,不能停止在中间), 一致性(Consistency事物在任何情况下保持一致),隔离性(Isolation格力状态执行事物, 同一时间仅有一个请求用于同一数据),持久性(Durability事物完成后, 该事物对数据库所做的更改就持久的保存在数据库中, 并不会被回滚)
END_Q

Q: 对于大表的常见优化手段
    web:https://juejin.im/post/5ba591386fb9a05cd31eb85f#1
    ANS: 限定数据范围
         读写分离
         缓存
         垂直分割
         水平分割
END_Q

Q: primary key 和unique key区别
    web:https://blog.csdn.net/industry2018/article/details/79460741
    ANS: 主键为了唯一标示一个字段, 不能为空, 自动生成索引
         unique key 约束字段上不允许有重复, 但可以为空
         主键=Not Null + unique key
         一个元祖中可以有多个unique key 但只能有一个主键
END_Q

Q: 使用事务时会出现的特殊读类型
    web:https://segmentfault.com/a/1190000012529474
        https://blog.csdn.net/tolcf/article/details/49283575
        https://www.cnblogs.com/itcomputer/articles/5133254.html
    ANS: 
        脏读: 事物对缓冲池中的记录进行修改, 还没提交, 这是被另一个事务读取. 可能会发生在未授权读取中
        不可重复读取: 一个事务内两次相同的操作读取结果不同.可能会发生在授权读取中,用next key lock避免, 在查询时对表范围添加排它锁, 避免在同一事物中出现不同的读取结果.
        丢失更新: 一个事物的更新操作被另一个事务更新操作覆盖, 一般不会发生在单用户数据库中, 但可能会发生在多用户数据库中. 需要串行化     
        不可重复读和幻读的区别: 不可重复读是数据的update&delete 幻读重点是insert.
        
END_Q

Q: B+树实现细节是怎么样的?B树和B+树有什么区别?联合索引在B+树中如何存储?
    web:http://blog.jobbole.com/111757/
        https://zhuanlan.zhihu.com/p/27700617
        https://www.cnblogs.com/gengsc/p/7230514.html
        https://www.nowcoder.com/discuss/101712
    ANS: 都是多岔平衡搜索树. B+树相比于B树而言, B+树的非叶子结点不保存数据只有索引信息, 而B树所有节点都有数据. 因此B+树可以存储更多数据, 树的深度更低, 导致IO次数更少,性能也更稳定. B+树在叶子节点上本质上是排序的双向链表, 在范围查询或者遍历时性能更高. 
END_Q

Q: 什么是乐观锁和悲观锁?
    web:https://blog.csdn.net/a520songhai/article/details/80991599
    ANS: 乐观锁就是对于并发操作可能的线程安全问题持乐观态度,在操作数据时不会对操作的数据加锁,这使得多个任务可以并行的对数据进行操作. 只有在提交数据时才通过机制验证是否存在数据冲突(一般用版本号/时间戳对比实现)
        悲观锁, 在操作数据前把数据锁住, 然后再对数据进行读写. 在释放锁之前, 其余的线程无法对数据进行操作. 性能不高, 
END_Q
Q: SQL存储过程和sql语句比较,哪个更好, 优点是什么?
    web:https://www.nowcoder.com/discuss/101712
    ANS: 在第一次打开并运行的时候存储过程和sql语句没什么区别.
        但存储过程在运行过一次后, 保存为编译后的状态, 之后再次运行可以不需要再次编译, 因此相较于sql语句更加节省带宽, 高速和安全.存储过程很大程度上可以防止sql注入. 
END_Q

Q: InnoDB的索引都有哪些?
    web:
    ANS: B+树索引, 自适应hash索引, 全文索引
        自适应hash索引只与数据库有关, 无法人为干预, 对等值查询很快, 但无法范围查找.
        B+树索引不能直接找到具体行, 只能找到数据行所在的页, 然后再内存中查找目标数据
        全文索引依靠倒排表.
END_Q

Q:innodb 哈希索引碰撞问题如何解决
    web:
    ANS: innodb中是链表
END_Q

Q: 聚集索引, 辅助索引和联合索引
    web:
    ANS: 聚集索引中的叶子节点有一整行的信息, 而辅助索引叶子节点只存放关键信息
        聚集索引就是按着每张表的主键构造B+树,同时叶子节点中存放的是整张表的全部行记录数据,每张表只有一个聚集索引
        辅助索引的叶子节点不存行的全部数据, 保存的除了键值以外, 每个叶子节点的索引行还有个书签, 用来告诉innodb哪里可以找到与索引对应的行数据,就是相应行数据的聚集索引键.就是说,在辅助索引找到目标后, 需要IO辅助索引深度+聚集索引深度才可能得到完整行数据

        联合索引:对表上的多个列进行索引. 联合索引可以避免查询时的排序操作.
END_Q

Q: 什么是组合(联合)索引, 应用组合(联合)索引的时候需要注意什么?(最左前缀)
    web:
    ANS: 联合索引就是对表上多个列建立索引. 适合于a或b条件单独查询结果很多, 但a&b查询结果很少的事务操作.
        联合索引查询必须在查询中包括最左边的列
        查询结果较少的列在前, 结果较多的列在后.
        对于最左边的列来说, 联合索引和本身的索引没什么区别(用法上)
        建立索引时应谨慎, 因为在建立索引时, innodb会锁住整个表, 影响性能.
        如果在某段时间内, 大量数据表有频繁更新, 可以先删除索引, 插入数据后在重新建立索引.
END_Q

Q: MySQL数据库引擎有了解吗
    web:
    ANS: 数据库可以后很多引擎, MySQL默认为Innodb, 但还有Myisam,ndb,memory等.
        innodb将数据放在表空间中, 默认为可重复读的隔离级别, 用next-key-lock来避免幻读(不可重复读)
        表中数据存放按着主键顺序存放. 要是没有主键就自动生成一个的主键.
        NDB是键值数据库存储引擎, 由于对join操作支持不好,导致性能不太好.
        MyISAM: 不支持事务,表锁设计, 支持全文索引, 缓存只缓存索引而不缓存数据.
        Memory: 内存数据库引擎, 适合存放临时表,默认用hash索引.并发性不好.
END_Q

Q: 如何防止sql注入
    web:
    ANS: 输入信息正则检查,加密,应用存储过程.限制用户权限.尽量不暴露太多异常信息.简单地说就是不相信用户的直接输入.
END_Q

Q:事务隔离级别是怎么实现的
    web:
    ANS: 基于共享锁和排它锁
        未授权读取:读不加锁, 写加行级排它锁直至事务结束
        授权读取: 读加行级共享锁直到读结束,写加行级排它锁直到事务结束
        可重复读取:next-key-lock=record lock(行锁)+gap lock(范围锁)
        串行化: 读加表级共享锁直到事务结束，写加表级排他锁直到事务结束
        
END_Q

Q:innoDB如何解决死锁问题
    web:
    ANS:等待图. 等待图保存着锁信息链表和事物的等代链表
        图中出现回路则证明有思索.
            等待图是一种主动检测死锁的方法
            被动的话可以等超时.
END_Q

Q: 数据库事务四种隔离级别
    web:https://segmentfault.com/a/1190000012529474
        https://www.cnblogs.com/sushu-yaya/p/6944287.html
    ANS: Read Uncommitted(未授权读取)(避免更新丢失,排它锁)
        Read Committed(授权读取)(避免更新丢失和脏读,用瞬间共享锁和排它锁)
        Repeatable Read(可重复读取)(避免更新丢失,脏读和不可重复读取, 但可能出现幻读)
        Serializable(串行化)
        隔离级别依次升高, 隔离级别越低, 系统开销越小, 并发支持越好.
        大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。
        Mysql的默认隔离级别就是Repeatable read。
END_Q

Q:数据库范式
    web:
    ANS:http://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html
        第一范式: 每列保持原子性,属性不可再分
        第二范式:表中每列都与与主键相关
        第三范式:表中每列都与主键直接相关
        BCNF:表中只有一个候选键
END_Q

Q:MySQL对比一下B+树索引和 Hash索引？(解释B+树索引和hash索引)
    web:
    ANS:
END_Q

Q:MySQL索引类型有？如何管理 MySQL索引？
    web:
    ANS:
END_Q

Q:对Explain参数及重要参数的理解？
    web:
    ANS:
END_Q

Q:索引利弊是什么及索引分类？
    web:
    ANS:
END_Q

Q:聚簇索引和非聚簇索引的区别？
    web:
    ANS:
END_Q

Q:B+tree 如何进行优化？索引遵循哪些原则？
    web:
    ANS:
END_Q

Q:索引与锁有什么关系？
    web:
    ANS:
END_Q

Q:还有什么其他的索引类型，各自索引有哪些优缺点？
    web:
    ANS:
END_Q

Q:说说数据库事务特点及潜在问题？
    web:
    ANS:
END_Q

Q:谈谈对Innodb事务的理解？
    web:
    ANS:
END_Q

Q:有多少种事务失效的场景，如何解决？
    web:
    ANS:
END_Q

Q:Innodb如何解决幻读？
    web:
    ANS:
END_Q

Q:一致性非锁定读和一致性锁定读是什么？
    web:
    ANS:
END_Q

Q:讲讲Innodb行锁？
    web:
    ANS:
END_Q

Q:死锁及监控是什么？
    web:
    ANS:
END_Q

Q:自增长与锁 ，锁的算法，锁问题，锁升级是什么？
    web:
    ANS:
END_Q

Q:乐观锁的线程如何做失败补偿？
    web:
    ANS:
END_Q

Q:高并发场景（领红包）如何防止死锁，保证数据一致性？
    web:
    ANS:
END_Q

Q:谈谈MySQL的锁并发？查询优化的基本思路是什么？
    web:
    ANS:
END_Q

Q:说说MySQL读写分离、分库分表？
    web:
    ANS:
END_Q

Q:表结构对性能有什么影响?浅谈索引优化？
    web:
    ANS:
END_Q

Q:说说Sql优化的几点原则？
    web:
    ANS:
END_Q

Q:说说MySQL几种存储引擎应用场景？
    web:
    ANS:
END_Q

Q:数据库优化方法?
    web:
    ANS:添加或者删除索引, 表的水平垂直分割, 重新设计表,增加缓池,分析慢查询日志
END_Q

Q:MySQL常用监控？MySQL瓶颈分析？
    web:
    ANS:
END_Q

