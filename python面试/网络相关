Q:根据ip地址和子网掩码求网络地址,主机号,广播号和主机最大数
    web:https://blog.csdn.net/linux12121/article/details/52045718
    ANS:ip地址和子网掩码按位与后得到的就是网络地址
        主机号就是子网掩码0的部分对应的ip地址转化成10进制
        广播号就是网络地址0的部分全是1
        能容纳的主机数是0的次数的2次方-2 (需要刨除主机地址和广播地址)
        最大数是2的多少个0次方
END_Q

Q: 自顶向下,网络五层结构
    web:
    ANS: 应用层(http,SMTP,DNS),传输层(TCP,UDP),网络层(IP),链路层(路由器,交换机),物理层(铜线,光纤)
END_Q

Q:TCP协议中的三次握手和四次挥手, 以及为什么要3次和4次
    web: https://blog.csdn.net/whuslei/article/details/6667471/
        http://blueskykong.com/2018/07/26/tcp-close-wait/
    ANS:
    三次握手:第一次,客户端向服务器端发送SYN同步报文段(里面有一个随机初始序号,SYN=1,seq=random()=client_isn) ,请求建立连接
            第二次,服务器端确认收到客户端的连接请求, 开始分配缓存和变量,并向客户端发送SYNACK报文(SYN=1,seq=random()=sever_isn,ack=client_isn+1),表示要建立连接.
            第三次, 客户端收到服务器端的确认请求后,分配缓存和变量, 处于连接状态, 并向服务器发送确认连接报文,可携带请求数据信息(seq=client_isn+1,ack=server_isn+1)
    四次挥手:第一次, 客户端向服务器端发送Fin结束报文, 准备关闭连接
            第二次, 服务器端向客户端发送确认Fin 的报文, 表示收到关闭连接请求,处于close wait状态
            (中间客户端停止向服务器端发送数据, 但服务器端可以发送数据, 把未完成的任务完成)
            第三次, 服务器端向客户端发送Fin报文, 准备关闭连接
            第四次, 当客户端向服务器端发送ACK, 进入Time_wait状态, 此时客户端进程已经退出, 但连接还在.
            (当服务器收到客户的ACK后断开连接, 当客户端等待2MSL'MSL为报文最大生存时间'后断开连接)
            (发起挥手的可能是任意一端)
END_Q

Q: TCP第三次握手失败后会发生什么?
    web:
    ANS:
        第三次握手失败后, 服务器会中断连接来防止SYN洪泛攻击,而不是重发SYN_ACK.
END_Q

Q:TCP协议为什么要三次握手和四次挥手? 为什么需要等待2*MSL?
    web:http://www.cnblogs.com/ranyonsue/p/10309292.html
    ANS:
    三次握手:一次握手肯定不行
            二次握手的话, 可能发生服务器端发给客户端的ACK报文丢失, 导致服务器端认为连接已经建立好了但客户端不知道. 浪费服务器端资源. 或者大量客户端的SYN洪泛攻击
            三次, 即使建立连接失败, 占用的也是客户端的连接位置.
            四次, 很浪费啊.
     四次挥手:因为当服务器端接收到客户端的FIN报文后, 可能还有数据未发送完, 需要继续发送.所以只能回复ACK+剩下的数据.
     2MSL: 防止最后一个ACK丢失, 2MSL是用来重发最后的ACK报文的.假设不等待2MSL直接关闭连接, 那么可能发生的是客户端发送的最后一个ACK中途丢失, 服务器重新发送ACK. 但客户端此时已经用同样的参数建立了新的TCP连接, 这样就会导致系统错误.
END_Q

Q: 状态码的意义
    web:
    ANS:状态码的第一个数字表示状态
        100 客户端需要继续发送请求
        200, 服务器成功返回网页
        301 永久重定向(搜索引擎目录变更)
        302 临时重定向(搜索引擎不变更url)
        401 用户需要验证
        404 请求的网页不存在
        500 服务器内部错误
        502 上有服务器接收到无效响应
        503 服务不可用
        1(临时响应)代表临时响应, 并需要请求者继续执行操作
        2(成功)代表成功处理请求
        3(重定向)表示要完成请求, 需要进一步操作, 通常用来重定向
        4(请求错误)表示请求出现错误, 妨碍了副武器的处理
        5(服务器错误)表示服务器在尝试处理请求时发生内部错误
END_Q

Q:SSL 是什么
    web:
    ANS:安全套接字层(secure socket layer),是在应用层上对TCP的安全加强,进程向SSL发送明文数据, SSL经过加密运算后,把数据给TCP. 接收方经TCP socket接收到加密的数据,传递给SSL,经SSL解密后传递给进程.
END_Q



Q: 什么是Cookie和Session?区别与应用?
    web:https://www.cnblogs.com/xxtalhr/p/9053906.html
        https://www.zhihu.com/question/19786827
    ANS:由于http是无状态的, 服务端需要机制来识别用户, 这个机制就是Session.比如说购物车.这个session是保存在服务端的, 有唯一标示. 保存session的方法有很多, 内存, 数据库, 文件都可以(或者专门的session服务器)每次在http请求时, 客户端会在报文中添加相应cookie信息到服务器端,(一般就是session ID名字，值，过期时间，路径和域)第一次创建session的时候, 服务端会在http报文中通知客户端在cookie中创建一个sessionID. 之后每次请求会把这个sessionID发送给服务端. 如果客户端禁用cookie的话, 可以使用URL重写的技术来进行会话跟踪, 每次http交互时, URL后面加一个sid=xxx.
     总的来说, session是一种状态, 用来跟踪用户状态,保存在服务器端, cookie是一种客户端保存用户信息的机制, 写满了不同服务端的sessionID或者用户名密码,用来实现session的一种方式.
     用一句话来总结一下的话就是.通常来讲session的常见实现要借助cookie来发送sessionID.
     (小心client side session. Flask采用的就是这种)
END_Q

Q:如果用户禁用了Cookies，如何获取用户的状态
    web:
    ANS:用URL传递sessionID,或者在网页中写入sessionID
END_Q

Q: SMTP和HTTP区别?
    web:
    ANS: 1.SMTP是一个推协议, HTTP是拉协议;2.SMTP要求7bitASCII码编码, http没有这种限制;3.http把每个对象封装在对象自己的报文中,SMTP把所有对象封装在一个报文中
END_Q

Q: DNS协议详解
    web:
    ANS:DNS客户端传送名称给服务器,服务器返回IP地址.用UDP发送,默认端口53. 三层DNS服务器, 根服务器(提供顶级域服务器地址), 顶级域服务器(.com.edu.cn提供权威服务器地址),权威服务器(提供真实地址). 除此之外, 还有独立的本地NDS服务器, 类似cache.有个解释图片.
    DNS网络可以使递归的,也可以是迭代的
END_Q
Q:简述多路分解和多路复用
    web:
    ANS:
END_Q
Q:HTTPS 与 HTTP区别?
    web:https://www.jianshu.com/p/6c981b44293d
    http://www.runoob.com/w3cnote/http-vs-https.html
    ANS:HTTPS=HTTP+SSL(secure socket layer) or TLS(transport Layer Security)
        对称加密和非对称加密
        (SSL/TLS 在三次握手中建立加密)
END_Q
Q:UDP端口号分哪三类?
    web:
    ANS:数值端口号, 注册端口号,客户端口号
END_Q

Q:一个应用程序用UDP，到了IP层把数据报再划分为4个数据报片发送出去。结果前两个数据报片丢失，后两个到达目的站。过了一段时间应用程序重传UDP，而IP层仍然划分为4个数据报片来传送。结果这次前两个到达目的站而后两个丢失。试问：在目的站能否将这两次传输的4个数据报片组装成为完整的数据报？为什么？假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中。
    web:
    ANS:不行, IP数据包的标识字段会有另一个标识符, 晋档标识符相同的IP数据报片才能组装成一个IP数据报
END_Q
Q: TCP滑动窗口(GBN)是如何工作的?
    web:
    ANS:有一个窗口用来控制每次发送量, 比如说发送方发送0~3pkt, #2pkt在发送过程中丢失, 那么当#3pkt到达接收方后(或者超时后), 接收方返回ACK1,并丢弃#3pkt. 然后发送方发送2~5pkts.这种方法的优点是,接收缓存简单, 接收方不需要缓存任何失序分组.缺点是当窗口长度和带宽时延很大时, 效率很低.
END_Q
Q: TCP选择重传(SR)如何工作?
    web:
    ANS:也是有一个窗口的, 假设窗口宽度为4, 现在又0~9个pkt需要传送. 第一次传送了#0~#3, #2丢失, 那么当发送方接收到ACK#1时,窗口移动到#2~#5, 发送#5. 当#2超时后, 重新发送#2, 假设#2被成功接收前, 3~5已经被成功接收, 那么当ACK#2被发送方接收后, 窗口移动到6~9.
END_Q
Q: TCP如何估计往返时间?
    web:
    ANS:超时间隔必须大于RTT. 大多数TCP在一段时间内仅在某一时刻做一次SAMPLE RTT的测量.然后用之前的SAMPLE RTT 和现在的SAMPLE RTT计算超时时间.
END_Q

Q: 简述TCP拥塞控制
    web:
    ref:<自顶向下>p180
    ANS:慢启动+拥塞避免+快速恢复. 初始发送速率为1MSS/RTT(就是一个pkt), 每接受到一个ACK发送方就将拥塞窗口增加一个MSS(发送速率翻倍). 增长停止的标志就是当发生丢包(或者三个冗余ACK)时,发送方将拥塞窗口cwnd大小重置为1MSS,设定SSthresh为拥塞窗口cwnd的一半.然后重新开始慢启动直到cwnd不小于ssthresh. (拥塞避免)之后每个RTT只将cwnd+1,当再次发生丢包或者三个冗余ACK时, cwnd变为原来的一半, ssthersh也变为原来的一半.然后进入快速恢复阶段, 每接收到一个引起快速恢复的冗余ACK后,cwnd+=1, 最终,对丢失报文的ack收到后, 重新进入拥塞避免状态.如果在快速恢复时发生超时, cwnd=1 ssthresh=cwnd/2. 重新回到慢启动.快速恢复是TCP推荐,而不是必须的.
END_Q

Q: TCP 流量控制 停等协议/滑动窗口(退回n步/选择重传)
    web: https://wenku.baidu.com/view/f15d7487b0717fd5360cdccf.html
    ANS: 流量控制就是发送方控制发送的数据量使之不超过接收方的接受能力.
        停等协议: 每次之传输一个包, 收到ack后才传输下一个,包丢失或者超时就重新传输.低效.
        滑动窗口:发送方和接收方都有一定容量的缓冲区, 允许发送方连续发送多个帧而不需要应答.
            发送窗口就是发送端允许连续发送帧的序号表.
            接收窗口是接收方允许接收的帧的序号表,落在接收窗口外的帧会被丢弃.
            窗口大小一般为序号大小的一半

Q: 判断题:IPv6将IP地址长度从32比特增加到了128比特，还引入了一种称为任播地址的新型地址
    web:
    ANS:没错
END_Q
Q:传送速率的单位“b/s”代表
    web:
    ANS:bit per second. byte是字节, 1byte=8bits. 1kb== 1024 bytes. 一般的与传输速度有关的b是bit, 与容量有关的b是byte.
END_Q
Q: 计算机网络协议的三要素
    web:
    ANS:语法语义和时序. 语法:用户数据与控制信息的结构与格式,以及数据出现的顺序.语义: 解释控制信息每个部分的意义, 它规定了需要发出何种控制信息以及完成的动作与做出什么响应. 时序: 对时间发生顺序的详细说明
END_Q
Q: 在距离向量路由中, 每个路由器从( )接收距离向量?
    web:
    ANS: 它的邻居
END_Q
Q:解释TCP快速重传
    web:
    ANS:快速重传是由冗余ACK来实现的. 发送#0~#3, #1丢失的话, 接收方即使受到#2和#3, 仍旧发送#0ACK, 这样发送方就知道#1没收到, 重新发送#1. 这比等待超时要快.(就是一直发送期待字节的序号)
END_Q


Q: TCP粘包和分包
    web:https://www.jianshu.com/p/79f37b79c8e1
    ANS: 粘包:TCP在建立长连接后,一段时间内发送不同结构数据. 由于TCP发送的是字节流, 发送端缓冲区中有前面的数据和后面的数据. 导致接收方无法区分这两种数据.
        粘包出现主要是1. 发送方需要等待缓冲区满才发送;2. 接收方不及时接收缓冲区的包,造成多个包接收.
        分包: 发送方可以强制数据不需要等待发送缓冲区满才发送. 接收方可以优化程序设计, 精简接收进程工作量, 提高接收进程优先级等措施, 尽量避免粘包.或者在应用层下定义一个协议, 消息头部+消息长度+消息正文.
END_Q

Q: 用户反映你的网站访问很慢(无响应)但其余网站正常, 请问如何排查
    web:https://blog.csdn.net/lv_victor/article/details/53148421
    ANS: 首先先假设这不是客户端的问题.
        1.服务器出口带宽不足(CDN,content-delivery-network：内容分发网络)
        2.跨运营商网络导致带宽减少(CDN,content-delivery-network：内容分发网络)
        3.服务器负载过大, 忙不过来了(买服务器或者优化代码)
        4.服务器代码写的不好, (逻辑代码或者数据库代码)(优化代码)
        5.数据库瓶颈(拆表/拆库/换数据库/增加内存数据库/换NoDB)
        
END_Q


            
END_Q
Q: HTTP 常用请求方法
    web:https://blog.csdn.net/zhangliangzi/article/details/51336564
    ANS: 
        GET:用于请求访问已经被URI识别的资源, 可以用URL传参
        POST:用于传输信息给服务器
        PUT:传输文件, 报文主体包含文件内容, 保存到对应的URI位置
        DELETE: 删除文件, 与PUT相反, 删除对应URI位置的文件
        OPTIONS: 查询相应URI支持的HTTP方法
        HEAD: 获得报文首部, 与GET类似, 但不返回报文主体
        URL:统一资源定位符
        URI:统一资源标识符
END_Q
Q: GET和POST的区别?
    web:https://blog.csdn.net/zhangliangzi/article/details/51336564
    ANS:
        一般情况下,GET用于获取数据, POST用于提交数据,
        受URL限制,GET传输的数据量小, 但效率高,POST可以传输大量数据
        GET不改变服务器状态, POST可以改变.
        GET相对不安全, 因为GET直接可见, 可能被浏览器记录
        GET只支持ASCII字符, POST 支持标准字符集.
END_Q

Q: 什么是REST 以及RESTFUL
    web:https://www.zhihu.com/question/28557115
    ANS: 
        看Url就知道要什么
        看http method就知道干什么
        看http status code就知道结果如何
END_Q

Q: 短URL实现
    web:https://www.zhihu.com/question/29270034
    ANS: 
        kv内存数据库+LRU或者分代回收
        给长地址发号, key就是长地址, v就是短地址.短地址可以直接用自增索引(发号器)或者直接用令牌池. 再加上LRU或者分代回收来回收过期的短地址.
        有计数的布隆过滤器也可以用来检测短地址是否被应用.
        然后长地址变成短地址后, 跳转301还是302的话,
        都可以, 但301是永久重定向, 302是临时重定向,302比较好, 搜索引擎会正确爬取保留网站内容(以旧的url为k存储). 301永久重定向后会将旧的网址转化成新的.
END_Q


END_Q
Q:怎么实现邮件黑名单功能
    web:
    ANS:白名单或者布隆过滤器黑名单
END_Q
Q:如何实现单点登录
    web:
    ANS:子服务器登录请求转移至主服务器, 主服务器针对sessionID发送令牌, 子服务器验证令牌, 设定令牌失效方法
END_Q

Q: TCP 和UDP 区别
    web:https://www.jianshu.com/p/79f37b79c8e1
    ANS: TCP是面向连接的, UDP是无连接的. TCP提供可靠服务, UDP不提供, TCP面向字节流, UDP面向报文. TCP有拥塞控制,UDP没有.
END_Q

Q:输入URL 回车后发生了什么?
    web:https://www.cnblogs.com/tisikcci/p/5866753.html
        https://www.jianshu.com/p/5d750867897a
        https://www.cnblogs.com/midiyu/p/7905554.html
    ANS:
        1. 解析URL, 抽取域名字段: 过滤?#之间是参数,多个参数用&连接
        2. 解析DNS,找到对应IP: 本地DNS服务器,递归查找三层DNS服务器:根,顶级,权威, 返回IP
            查询浏览器dns缓存, 查询本地客户端hosts文件, 本地dns服务器,根,顶级,权威递归查找
        3. 与服务器建立连接: 三次握手
        4. 请求数据
            http请求包含请求头(和可能有的)请求体两部分,请求头包含我们希望对请求文件的操作信息,请求体包含传递给后台的参数
        5. 服务器后台操作并响应
            后端的工作(nignx+uwgi+flask),数据处理完毕后, 生成响应数据包, 包含响应头和响应体两部分.
        6. 浏览器页面渲染: 客户端收到数据, 用页面渲染引擎处理页面.
            浏览器加载html文件后,由上到下解析成dom树, 直到html结束标签停止.
        7. 断开连接
END_Q

Q: TCP为什么是可靠的?
    web:https://blog.csdn.net/baidu_35692628/article/details/78255476
    ANS:
        0.面向连接:三次握手,四次挥手
        1.确认和重传机制: 建立连接时三次握手同步双方的序列号+确认号+窗口大小是确认重传,流控的基础
                在传输过程中如果checksum校验失败,丢包或延迟,发送端重传
        2.数据排序: TCP有专门的序列号SN字段, 可提供数据re-order
        3.流量控制: 窗口和计时器的使用,tcp窗口中会指明双方能够发送接收的最大数据量
        4.拥塞控制: 慢启动,拥塞避免,快速恢复
        0.面向连接: TCP是面向连接的协议, 需要三次握手和四次挥手才会建立及中断连接.
        1.确认和重传: 发送方和接收方会对每一个数据据包进行收到确认和检查checksum,如果出问题选择重新传送
        2.数据排序: tcp有专门的序列号SN字段, 可提供数据排序
        3. 流量拥塞控制: 慢启动+拥塞避免+快速恢复
END_Q

Q:说说滑动窗口协议?
    web:
    ANS:滑动窗口协议属于TCP协议的一种应用, 用于网络数据传输时的流量控制,和停等协议不同, 滑动窗口协议可以一次性发送和接收多个数据分组, 提高网络吞吐量.
    然后说说GBN和SR
END_Q